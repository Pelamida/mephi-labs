ASCII - числовые коды символов от 0 до 127 (7 разрядов)
65 = сhar А

Unicode = 96000, -> ISO/IEC 10646

char = 'x' - символ
char symb = 'D' == 'ABCD' - последний символ

//Управляющие последовательности
\a     предупреждение     не меняет позиции курсора
\b     1 позиция влево    на один символ назад
\f     перевод страницы   в начало следующей страницы
\n     новая строка
\r     возврат каретки    в начало текущей строки
\t     гориз табуляция    в след точку гт
\v     верт табуляция     в след точку вт
\\     обратная косая черта
\'     одиночная кавычка
\"     двойная кавычка
\?     вопросительный знак
\0--   восьмеричное значение (две восьм цифры)
\x--   шестнадцатиричное значение (1-3 (2) шесн цифры)

ch = '\032'; /* ASCII-код 26 в 8-ричной системе счисления */
ch = '\x1A'; /* ASCII-код 26 в 16-ричной системе счисления */
ch = 032; /* возможно, но нежелательно! */

printf: символ - %с, значение - %d

//Строки
окончание строки - нулевой символ '\0'
массив для хранения строки длины строка+1
printf:("%s", str), сам добавит и уберет нулевой символ
При считывании введенных данных scanf останавливает чтение на пробеле, табуляции и новой строке

сh = getchar() <==> scanf("%c", &ch);
putchar(ch) <==> printf("%c", ch);

#include <ctype.h>
функции возвращают  истинное значение, если:
isalnum()	буква или цифра
isalpha()	буква
isblank()	пробел
iscntrl()	управляющий символ (ctrl+v)
sidigit()	цифра
isgraph()	любой печатный непробельный символ
islower()	символ в нижнем регистре
isprint()	печатный символ
ispunct()	знак пунктуации
isspace()	любой непечатный и пробельный символ
issupper()	символ в верхнем регистре
isxdigit()	шестнадцатиричная цифра

tolower()	перевод символа в нижний регистр
toupper()	перевод символа в верхний регистр



gets(st) считывает строку до enter, возвращает адрес массива, не проверяет на вместимость в массив
fgets(st, lenth, stdin) сохранит \n

puts(st) puts(&st[4]); выводит строку

#include <string.h>
strcpy(s1, s2)	копирование 2 в 1
strcat(s1, s2)  присоединение (конкатенация) 2 в конец 1
strlen(s)		возвращает длину строки
strcmp(s1, s2)	0, если s1=s2; <0, если s1<s2; >0, если s1>s2
strchr(s, ch)	указатель на первое вхождение символа в строку
strstr(s1, s2)	указатель на первое вхождение строки в строку

atoi(s)	преобразует числовую строку в int
stol(s) в long int
atof(s) в double
до первого нечисленного символа



while ((c = getchar()) != '\n')
	putchar(c);
putchar(c); 

#include <stdio.h>
int main(void) {
int c; //int имеет более широкий диапазон значений, чем char
while ((c = getchar()) != EOF) /* пока не конец файла */
	putchar(c);
putchar(c);
return 0;


Подсчет количества символов
long int nc;
for (nc = 0L; getchar() != EOF; ++nc);

Подсчет количества слов и строк
#include <stdio.h>
#include <ctype.h>
#define IN 1 /* внутри слова */
#define OUT 0 /* снаружи слова */
int main(void) {
	int c, /* текущий символ */
		state, /* состояние потока (внутри или снаружи слова) */
		nc, /* количество символов (number of characters) */
		nw, /* количество слов (number of words) */
		nl; /* количество строк (number of lines) */
	state = OUT;
	nc = nw = nl = 0;
	while ((c = getchar()) != EOF) { /*пока не найден конец файла*/
		++nc;
		if (c == '\n') /* если текущий символ - конец строки */
			++nl;
		if (isspace(c)) /* если текущий символ - пробельный */
			state = OUT; /*текущий символ находится снаружи слова*/
		else if (state == OUT) { /*если предыдущий символ снаружи слова*/
			state = IN; /* текущий символ находится внутри слова */
			++nw;
		}
	}
	printf("Символов: %d; слов: %d; строк: %d.\n", nc, nw, nl);
	return 0;
}

prog - исполняемая программа
prog <file1 		перенаправление ввода из файла 1
prog >file2			перенаправление вывода в файл 2
prog <file1 >file2	одновременное перенаправление ввода
prog >file2 <file1	из файла 1 и вывода в файл 2


//Файлы
стандартный ввод stdin, вывод stdout, вывод ошибок stderr
fopen(адрес строки с именем файла, строка с реж.открытия)

"r"	открыть текстовый файл для чтения
"w"	открыть для записи, длина до 0, создается, если нет
"a" открыть файл для записи, добавляя данные в конец
"r+"	 открыть текстовый файл 
"w+"	 для обновления 
"a+"	 (чтения и записи)

"rb" "wb" "ab"
"rb+" "r+b"
"wb+" "w+b"
"ab+" "a+b"
то же самое, но вместо текстового режима доступа двоичный
fopen возвращает указатель на файл. Если не может открыть файл, то возвращает пустой указатель NULL
FILE *fp;
if ( (fp = fopen("myfile.txt","r")) == NULL ) {
	printf("Не удается открыть файл.\n");
	exit(1); /* завершение программы с возвратом кода ошибки 1 */
}

fclose(fp) закрывает файл, возвращает 0, если успешно, и EOF в противном случае

exit() завершает программу из любого ее места и закрывает все открытые файлы, возвращает 0 в случае успешного завершения и ненулевое значение в случае аварийного

Файловая функция 		Аналог
getc(fp)				getchar()
putc(ch, fp)			putchar(ch)
fprintf(fp, ...)		printf(...)
fscanf(fp, ...)			scanf(...)
fgets(buf, MAX, fp)		gets(buf)
fputs(buf, fp)			puts(buf)
(buf - массив символов, MAX - целое число, опред. макс размер входной строки)

В строку добавляется нулевой символ '\0'. Если считана целая строка (длина которой меньше MAX-1), то перед нулевым символом добавляется символ новой строки.
fputs() при выводе не добавляет символ новой строки.

getc() возвращает EOF, но конец файла не достигнут:
- производится чтение из двоичного файла и прочитанное целое оказалось равным коду EOF
- в случае возникновения ошибки при чтении
feof(bfr) возвращает ненулевое, если обнаружен маркер конца файла и 0 в противном случае
ferror(fp) возвращает неноль, если произошла ошибка

Пример чтения двоичного файла:
int a; /* текущее прочитанное число */
FILE *bfp; /* указатель на файл */
bfp = fopen("binaryfile.dat","rb"); /* открытие файла */
while (!feof(bfp)) //пока не обнаружен маркер конца файла
	a = getc(bfp);
fclose(bfp); /* закрытие файла */

getc(fp);
if (!ferror(fp)) {
	printf("Ошибка чтения/записи файла.\n");
	exit(1);
}

Чтение текстового файла и вывод его на экран посимвольно
int ch;
FILE *fp;
fp = fopen("myfile.txt","r");
while ((ch = getc(fp)) != EOF)
	putchar(ch);
fclose(fp);


fseek(fp, смещение, отправная точка) перемещает текущую позицию в файле
ftell(fp) возвращает текущую позицию в файле (long int)
SEEK_SET начало файла
SEEK_CUR текущая позиция
SEEK_END конец файла
fseek(fp, 0L, SEEK_SET); /* в начало файла */
fseek(fp, 10L, SEEK_SET); /* на 10 байтов вперед от начала файла */
fseek(fp, -10L, SEEK_END); /* на 10 байтов назад от конца файла */
