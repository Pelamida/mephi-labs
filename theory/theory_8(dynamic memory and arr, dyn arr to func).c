//Динамические - переменные, которые создаются и удаляются во время выполнения программы
Создаются в отдельной специальной области памяти - динамически распределяемой области (кучи, heap)

/*Раздел статических переменных*/- память выделяется в начале выполнения программы и освобождается в момент завершения работы программы
/*Раздел автоматических переменных*/ - память выделяется, когда происходит вход в блок кода, содержащий объявление этой переменной, и освобождается в момент выхода из этого блока
/*Раздел динамически распределяемой памяти*/ - память выделяется при вызове malloc() и освобождается при вызове free()

/*sizeof выражение      sizeof (ИмяТипа)*/
Возвращает количество байт, требуемое для хранения того типа, который имеет операнд. При применении к массиву дает общее количество байт в нем

/*malloc(количество байтов памяти)*/ отыскивает подходящий непрерывный фрагмент в свободной области памяти и возвращает адрес первого байта этого блока в виде общего указателя (на void,), его можно присвоить указателю любого типа без ошибки
Нет такого фрагмента - нулевой указатель NULL
/*free(адрес malloc())*/ освобождает выделенную malloc, callos или reallos память

Обращение к динамическим переменным происходит через имена их указателей
double *p;     /*Указатель в неопределенном состоянии.*/
p = (double *) malloc(sizeof (double));  /* Указатель */
*p = 123.4567;     /* содержит адрес блока памяти для */
printf("%f", *p);  /* хранения переменной типа double.*/
free(p);       /*Указатель в неопределенном состоянии.*/

//Массив переменной длины
Стандарт ANSI: нельзя объявить массив переменной длины, используя для обозначения размера массива переменные

Пример создания дин.массива чисел типа double
#include <stdio.h>
#include <stdlib.h>
int main(void) {
	int i,n;
	double *pa; /*Указатель pa – динамический массив.*/
	printf("Введите количество элементов массива: ");
	scanf("%d", &n);
	pa = (double *) malloc(n * sizeof (double)); /*Выделение
 памяти (n ячеек размером double) для массива pa.*/
	if (pa == NULL) { /*Проверка успешности выделения памяти.*/
		printf("Не удалось выделить память.");
		exit(EXIT_FAILURE); /*Аварийное завершение программы.*/
	}
	for (i=0; i<n; ++i) {
		pa[i] = (double) rand() / (RAND_MAX + 1.0);
	}
	for (i=0; i<n; ++i) {
		printf("%7.5f ",pa[i]);
	}
	free(pa); /*Освобождение памяти, выделенной для массива */
	return 0;
}
Результат, возвращаемый функциями выделения памяти всегда нужно проверять на равенство NULL, может отсутствовать свободный непрерывный блок памяти необходимого размера


/*callos(n, size)*/ выделяет блок памяти из n элементов размером size байт, заполняет все его биты нулями и возвращает адрес блока (не гарантируется, что в ячейках окажутся нулевые значения, но для int работает)

/*reallos(p, size)*/ изменяет размер блока памяти, на который указывает p, до size байт и возвращает адрес измененного блока.
Может вернуть указатель на новый блок памяти, если исходный блок не удалось изменить (при этом значения элементов исходного копируются в новый,  а выделенная для исх. блока память освобождается)
Нужно использовать вспомогательный указатель, чтобы не потерять указатель на исходный блок памяти в случае ошибки

realloc(NULL,size) == malloc(size)
realloc(p,0) == free(p)

Пример увеличения размера массива в ходе выполнения программы:
#include <stdio.h>
#include <stdlib.h>
int main(void) {
	int i,
	*p, /* p – динамический массив.*/
	*q; /* q – вспомогательный указатель.*/
	p=(int*)calloc(5,sizeof(int)); /*Выделение 5-и ячеек памяти.*/
	if (p==NULL) { /*Проверка успешности выделения памяти.*/
		printf("Не удалось выделить память.");
		exit(EXIT_FAILURE);
	}
	for (i=0; i<5; ++i)	p[i]=i;
	q=(int*)realloc(p,10*sizeof(int));/*Увеличение до 10-и ячеек.*/
	if (q==NULL) { /*Проверка успешности увеличения памяти.*/
		printf("Не удалось увеличить память.");
	}
	else {
	p=q;
	for (i=5; i<10; ++i) p[i]=i;
	}
	free(p); /*Освобождение памяти.*/
	return 0;
}

Массив передается в функцию по его названию - указателю на первый элемент.
Динамический массив следует передавать по указателю на указатель первого элемента массива

Увеличение размера динамического массива в функции
void func(int **a, int n) { /* a – указатель на указатель */
	int *q;
	q = (int*) realloc(*a, 1000*sizeof(int));
	if (q==NULL) printf("Не удалось увеличить память.");
	else {
		*a = q; //указатель на первый элемент массива
		(*a)[999] = 123; /* или ((*a)+999) = 123;*/
		...
	}
}
int main(void) {
	int *pm;
	pm = (int*) malloc(10*sizeof(int));
	...
	func(&pm,10); /* в функцию передается адрес указателя pm */
	...
	free(pm);
}

первый элемент массива   **a      *(*a)   (*a)[0]
i-й элемент массива   *((*a)+i)  *(*a+i)  (*a)[i]

