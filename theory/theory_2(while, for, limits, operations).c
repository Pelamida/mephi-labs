//Инкремент, декремент и операции с присваиванием
Инкрементирование (унарная) - добавляет к операнду 1 
(++а) - увеличение до использования а, (а++) - после
Декрементирование - аналогично, (а--), (--а)
Работает только с переменными. Высокий приоритет, <-
b = ++a <=> a=a+1, b=a
b = a++ <=> b=a, a=a+1
Нельзя использовать, если переменная встречается в выражении более одного раза

Операции                     Ассоциирование        Приоритет
() [] -> .                         →             высокий (15)
! ~ ++ -- + - * & (тип) sizeof       ←                 (14)
* / %                              →                 (13)
+ -                                →                 (12)
<< >>                              →                 (11)
< <= > >=                          →                 (10)
== !=                              →                 (9)
&                                  →                 (8)
^                                  →                 (7)
|                                  →                 (6)
&&                                 →                 (5)
||                                 →                 (4)
?:                                 ←                 (3)
= += -= *= /= %= &= ^= |= <<= >>=  ←                 (2)
,                                  →              низкий (1)


#define while
//Предусловие:
while (Выражение) {
    ОператорХ;
}

//Постусловие:
do {
    ОператорХ;
} while (Выражение)
Обязательно выполнится хотя бы один раз

#define for

for (ВыражИниц; ВыражУсл; ВыражИзмен)
    Оператор
    
//for (i=1; i<=20; i++)
//    sum += i;

continue прерывает текущую итерацию цикла и переходит к следующей
goto - безусловный переход к метке
while (...) {
 for (...) {
 for (...) {
 Операторы
 if (Ошибка)
 goto label; /* переход к метке */
 }
 Операторы
 }
 Операторы
 }
 Операторы
 label: УстранениеОшибки;


//НОД, алгоритм Евклида
a >= b
b = 0  -> НОД(a,b) = a
b != 0 -> НОД(a,b) = НОД(b, a%b)

#include <stdio.h>
int main(void) {
 long int a, b;
 printf("Введите два числа, не равные нулю: ");
 scanf("%d %d", &a, &b);
 do {
 if (a>b) a %= b;
 else b %= a;
 } while (a!=0 && b!=0);
 printf("НОД =%d\n", a+b);
 return 0;
}


//Оптимизация
for (i=1; i<=1000; i++)
 sum+=a*i;   
 ->
 sum+=i;
sum*=a; //одна операция умножения вместо 1000

Если какое-то выражение можно обозначить, чтобы не считать его каждый раз - обозначь


<limits.h> размеры целочисленных типов данных
INT_MAX максимальное значение int
INT_MIN минимальное значение int
LONG_MAX максимальное значение long int
LONG_MIN минимальное значение long int
UINT_MAX максимальное значение unsigned int
ULONG_MAX максимальное значение unsigned long int
Удобно использовать для отслеживания переполнения

if (a <= UINT_MAX-b) a ++ b;
