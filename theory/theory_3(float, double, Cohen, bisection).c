//Одинарная точность, 32 bit, float (single precision)
4 байта = 32 бита = 1 знак + 8 порядок + 23 мантисса
порядок смещен на 127=01111111 - можно записать от -127 до 128
мантисса 1<=m<2

//Двойная точность 64 bit, double (double precision)
8 байт = 64 бита = 1 знак + 11 порядок + 52 мантисса

Ноль закодирован как +0 и -0

//Денормализованные числа
порядок равен 0 (-127+127), мантисса 0.1<=m<1, дробная часть - любая, кроме 0

//Бесконечность +-
Число с макс порядком (все 1) и нулевой дробной частью мантиссы (все 0)

//Не число (Not a Number, NaN) +-
Максимальная порядок (все 1) и ненулевая дробная часть мантиссы
Операции, приводящие к NaN:
- все математические операции, содержащие NaN в качестве одного из операндов;
- деление нуля на нуль;
- деление бесконечности на бесконечность;
- умножение нуля на бесконечность;
- сложение бесконечности с бесконечностью противоположного знака;
- вычисление квадратного корня отрицательного числа;
- логарифмирование отрицательного числа;
- при вычислении pow(+-0,+-0) по стандарту IEEE 754-2008

//Вещественные типы данных
float (одинарной точн)   кол-во значащих цифр не меньше 6
double (двойной)                               10
long double (повышенной)                       10

0,9Е-3 = 0.9*10^-3   0.62e+4=0.62 *10^4 (е Е без разницы)

//Стандартные мат функции в <math.h>
fabs(x)           модуль
sqrt(x)           квадратный корень   
sin, cos, tan
asin, acos, atan
exp(x)            экспонента
log(x)            натуральный логарифм
log10(x)          десятичный логарифм 
sinh, cosh, tanh  гиперболические триг функции

В вещественных типах ==, !=, <=, >= использовать бессмысленно

//Сравнение чисел с плавающей точкой
Сравнивают их разность с малой величиной eps, задающей точность сравнения
double x, y, eps=0.000001;
if ( fabs(x-y) < eps )
   printf(" x=y с точностью %lf\n",eps);

Вычисление суммы ряда
Формула буп S = b1/(1-q)
int main(void) {
 double b, q, S, eps=1e-6;
 b = q = (double)1/3; /* b - значение первого члена ряда */
 S = 0.0; /* начальное значение суммы S */
 while (b > eps) { /* условие остановки суммирования */
 	S += b; /* накапливание суммы */
 	b = b*q; /* вычисление следующего члена ряда */
 }
 printf("S=%.20lf\n", S);
 return 0;
}

//Метод Кохена
Имеется цикл для вычисления суммы, очередное слагаемое присваивается переменной f на каждой итерации цикла, сумма накапливается в переменной S. Тогда введем значение коррекции – переменную cor, а также промежуточные переменные fcor – скорректированное слагаемое и Scor – скорректированная сумма.
  S = 0.0; cor = 0.0; Scor = 0.0;
  for (i=1; i<=MAX; i++) {
  	f = <очередное i-е слагаемое>;
  	fcor = f - cor;
  	Scor = S + fcor;
  	cor = (Scor - S) - fcor;
  	S = Scor;
  }
Здесь S – большое число, а fcor – маленькое, и при суммировании младшие биты fcor теряются. Подставляя выражение
Scor = S + fcor
в строку
cor = (Scor - S) - fcor
для точных значений получается
cor = ((S + fcor ) - S) - fcor = 0
Но для чисел с плавающей точкой поправочный член cor чаще всего ненулевой, и точность вычисления повышается.

//Метод деления пополам, бисеции, дихотомии
Точность вычислений - 2 способа:
1) по оси абсцисс ex: x = x0+ex, решение в пределах заданной погрешности, делим по х
2) по оси ординат ef: x = x0 +- L/2^n, делим по у
(n - кол-во итераций деления отрезка пополам)

Другие методы: простой итерации (последовательных приближений), хорд (секущих), Ньютона (касательных)

//Абсолютная и относительная погрешности
а - приближенное, А - точное число
абсолютная: delta = |A-a| <= delta_a 
delta_a - предел абсолютной погрешности, если А не известно, А = а +- delta_a
в качестве delta_a выбирают наименьшее возможное число
относительная: sigma = delta / |A|

//Верные значащие цифры
Первые n значащих цифр прибл числа верные, если абс погрешность не превышает половины единицы разряда, выражаемого n-й значащей цифрой

Пример. А=35,97, а=36,00
|A-a|=0.03<0.05 = 1/2*0.1 = 1/2 * 10^-1 = 1/2 * 10^(m-n+1)
m-n+1 = -1
a = 3*10^1 + 6*10^0 + 0*10^-1 + 0*10^-2 => m=1 (степень 10 при старшем десятичном разряде) => n=3
Для точного А число а явл приближенным с тремя верными значащими цифрами

