Временная эффективность - индикатор скорости работы алгоритма
Пространственная эффективность - сколько доп оперативной памяти нужно для работы алгоритма

Временая сложность алгоритма - время, затрачиваемое на решение задачи с помощью этого алгоритма, выраженное через n
Асимптотическая временная сложность - поведение функции временной сложности при увеличении размера задачи n

O(C*f) = C*O(f)    C = const
O(f*g) = O(f)*O(g)
O(f+g) = доминанта O(f) и O(g)

O(1)                констатная
O(log2(n))          логарифмическая
O(n)                линейная
O(n*log2(n))        порядка n*log2(n)
O(n^2), O(n^a)      полиномиальная
O(2^n)              экспоненциальная
O(n!)               факториальная

//Методы сортировки со сложностью порядка n*log2(n)
- быстрая сортировка (Quicksort)
- сортировка слиянием (Mergesort)
- пирамидальная сортировка (кучей, Heapsort)

Общие описания
#define n 20
int A[n];
void swap(int *x, int *y) {
 int temp; 
 temp=*x;
 *x=*y;
 *y=temp;
}

Быстрая сортировка (метод Хоара)
Фиксируется опорный элемент (ключ), относительно кoторого все меньшие элементы перемещаются влево, а большие - вправо, затем процесс повторяется для каждой части отдельно

void QuickSort(int first, int last) {
 int pivot; /*опорное значение*/
 int l,r; /*левый и правый счетчики*/
 l=first; r=last;
 pivot=A[(l+r)/2]; /*определение опорного значения*/
 while (l<=r) {
 	while (A[l]<pivot) l++;
 	while (A[r]>pivot) r--;
 	if (l<=r) {
 		swap(&A[l],&A[r]); /*перестановка двух элементов*/
 		l++;
 		r--;
 	}
 } /*Рекурсивная сортировка:*/
 if (first<r) QuickSort(first,r); /*левого участка */
 if (l<last) QuickSort(l,last); /*правого участка*/
 }
...
QuickSort(0,n-1);

//Сортировка слиянием
Массив разделяется на две части, которые сортируются независимо друг от друга, затем результаты объединяются (сливаются) в единый упорядоченный массив. Разделяются до тех пор, пока количество элементов в сортируемой части не станет равно двум.

void Merge(int first, int last)
 {
 int B[n]; /*вспомогательный массив*/
 int k; /*индекс во вспомогательном массиве*/
 int l,r; /*левый и правый счетчики*/
 int m; /*индекс среднего элемента*/
 m=(first+last)/2;
 l=first; r=m+1;
 k=0;
 while (l<=m && r<=last) { /* Пока не закончился */
 	if (A[l]<=A[r]) { /*хотя бы один фрагмент.*/
 		B[k]=A[l]; l++; }
 	else {
 	B[k]=A[r]; r++; }
 	k++; } /*Один из фрагментов закончился.*/
 /*Переносим остаток другого фрагмента во вспомогательный
 массив.*/
 while (l<=m) B[k]=A[l]; l++; k++; 
 while (r<=last) B[k]=A[r]; r++; k++; 
 for (l=0; l<k; l++) A[first+l]=B[l];
 }
 
void MergeSort(int fst, int lst)
 {
 int m; /*индекс среднего элемента*/
 if (fst<lst)
 	if (lst-fst==1) {
 		if (A[lst]<A[fst]) swap(&A[fst],&A[lst]);
 	}
 else {
 	m=(fst+lst)/2;
 	MergeSort(fst,m);
 	MergeSort(m+1,lst);
 	Merge(fst,lst);
 	}
 }
...
MergeSort(0,n-1);

//Пирамидальная сортировка
Элементы массива образуют пирамиду, если для всех значений выполяются условия A[i]≤A[2·i] и A[i]≤A[2·i+1].
В «вершине» пирамиды находится минимальный элемент. Поместим его в результат, а на его место поставим максимально допустимое в данном диапазоне значение и протолкнем его по пирамиде. После этого в вершине пирамиды опять появится очередной минимальный элемент. Поместим его в результат. Процесс продолжается до тех пор, пока в пирамиде не останется элементов (все элементы «протолкнули» через пирамиду). В результате получим отсортированный массив.

void TreeRebuild(int r, int q)
 {
 int v;
 int i,j;
 int pp;
 i=r; /*индекс рассматриваемого элемента*/
 v=A[i]; /*рассматриваемый элемент*/
 j=2*i+1;/*индекс элемента, с которым проводится сравнение*/
 pp=0; /*предположение, что не найдено место в пирамиде*/
 while (j<=q && !pp) {
 	if (j<q)
 		if (A[j]>A[j+1]) /*сравнение с меньшим элементом*/
 			j++;
 	if (v<=A[j])
 		pp=1; /*элемент стоит на своем месте*/
 	else {
 		A[i]=A[j]; /*перестановка элемента*/
 		i=j;
 		j=2*i+1; /*прохождение дальше по пирамиде*/
 	}
 }
 A[i]=v;
}

void TreeSort()
 {
 int k,i;
 k=n/2; /*эта часть массива является пирамидой*/
 for (i=k-1; i>=0; i--)
 	TreeRebuild(i,n-1); /*построение пирамиды (только один раз)*/
 for (i=n-1; i>=1; i--) {
 	swap(&A[0],&A[i]); /*перестановка 0-го и i-го элементов*/
 	TreeRebuild(0,i-1); /* «проталкивание» i-го элемента*/
 }
}
...
TreeSort();







