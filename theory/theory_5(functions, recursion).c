//Функции
ТипВозвращЗначений ИмяФункции(ОбъявленияПараметров) {...}
(формальные параметры описаны в заголовке, фактические передаются в нее при вызове, а внутри функции локальные переменные)

Если функция стоит после main(), то нужно написать ее прототип до main() (то есть первую строку, до {})
(либо int power(int, int))

Вызов функции - фактические параметры
Чтобы изменять глобальные переменные, нужно использовать указатели (передача "по адресу")

void swap(int *px, int *py) {
int temp;
temp = *px;
*px = *py;
*py = temp; }
int a=2, b=3;
swap(&a, &b);

//Несколько возвращаемых значений
Берем две переменные, которые будут изменяться глобально

//Задача об отслеживании переполнения
Слагаемые передаем по значению, значение функции - код ошибки (0/1), сумма - по адресу
#include <stdio.h>
#include <limits.h>
int calcul(int x, int y, int *sum, int *prod);
int main(void) /* главная функция программы */ {
	int a, b, s=0, p=0; /* фактические параметры */
	int error_code; /* код ошибки */
	printf("Input a: "); scanf("%d", &a);
	printf("Input b: "); scanf("%d", &b);
	error_code = calcul(a,b,&s,&p); /* вызов функции */
	if (error_code) /* проверка кода ошибки */
		printf("Overflow error: %d.\n", error_code);
	else
		printf("a+b=%d, a*b=%d.\n", s, p);
	return 0;
}
int calcul(int x, int y, int *sum, int *prod) {
	if (x<=INT_MAX-y) /* проверка переполнения для сложения */
		*sum = x + y;
	else
		return 1; //возврат кода ошибки переполнения сложения 
	if (x<INT_MAX/y+1) //проверка переполнения для умножения
		*prod = x * y;
	else
		return 2; //возврат кода ошибки переполнения умножения
	return 0; //возврат кода успешных операций (без переполнения)
}

Автоматические переменные - локальные, начинающие свое сущ при вызове функции и прекращающие при выходе из нее
Внешние переменные - определены за пределами всех функций

Перевод в СС
#include <stdio.h>
#define BASE 3
long int BASEto10(long int a);
int main(void) {
	long int x, y;
	printf("Ternary notation: (input only digits 0,1,2) a=");
	scanf("%ld", &x);
	y = BASEto10(x);
	printf("Decimal notation: a=%ld\n", y);
	return 0;
}
long int BASEto10(long int a) {
	int k=1;
	long int a10=0;
	while (a) {
		a10 += k*(a%10);
		k *= BASE;
		a /= 10;
	}
	return a10;
}

Глубина рекурсии - максимальное число рекурсивных вызовов функции без возвратов
Текущий уровень рекурсии = число рекурстивных вызовов в каждый момент времени

Рекурсивные функции требують значительно большего объема оперативной памяти, что может привести к переполнению, выполняются медленнее, но код с рекурсией компактнее и его легче писать и дорабатывать

Главное требование к рек функциям - вызов должен выполняться по условию, которое на каком-то уровне станет ложным
Условие истинно - рекурсивный спуск продолжается, ложно - рекурсивный возврат
