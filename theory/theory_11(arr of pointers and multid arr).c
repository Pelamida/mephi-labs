//Создание и использование массива указателей
Если нужно отсортировать по возрастанию числа массива, но при этом запрещено их переставлять и копировать, можно создать новый массив, в котором будут храниться индексы элементов исходного массива в порядке возрастания значений этих элементов ind[]

Если массивов несколько - создают общий массив указателей arp[] (&a[3], &b[1]...)
*(arp+i), arp[i] - адрес  
*arp[i], **arp - значение
*arp+1 - следующий элемент одного из исходных массивов
*(*(arp+n)+i) == *(arp[n]+i) - значение i-го элемента исходного массива

Двухмерный массив
int m[10][20];
int m[2][3] = { 
	{1, 2, 3}, 
	{4, 5, 6} 
};
int m[2][3] = {1, 2, 3, 4, 5, 6}
при частичной инициализации недостающие элементы будут заполнены нулями

Многомерный массив
int m[a][b][c][d][e]...
При использовании в качестве параметра функции нужно указать количество элементов в каждом измерении, кроме самого первого (левого)
Значения: **arr
*(*(arr+n)+m) == arr[n][m]

Поиск максимального элемента матрицы и его индексов
void SearchMax(int a[][m],
		int *amax, 
 		int *imax, int *jmax) { 
 	int i; /* счетчик по строкам от 1 до n */
 	int j; /* счетчик по столбцам от 1 до m */
 	*amax=a[0][0];
 	*imax=0; *jmax=0;
 	for (i=0; i<n; i++)
 		for (j=0; j<m; j++)
 			if (a[i][j] > *amax) {
 				*amax=a[i][j];
 				*imax=i; *jmax=j;
 			}
}
...
SearchMax(matrix, &am, &im, &jm)

Проверка симметричости квадратной матрицы
int Symmetric(int mtr[n][n]) {
 	int i; /* счетчик по строкам */
	int j; /* счетчик по столбцам */
 	for (i=0; i<n-1; i++)
 		for (j=i+1; j<n; j++)
 			if (mtr[i][j]!=mtr[j][i])
 				return 0;
 	return 1;
}

вектор-столбец * вектор-строка = матрица
вектор-строка * вектор-столбец = 1 значение

произведение матрицы 3*5 и вектора-столбца 3*1
void Mult(int mtr[n][m], /* матрица 3x5 */
 int vm[m], /* вектор-множитель 5x1 */
 int vn[n]) { /* вектор-результат 3x1 */
 int i; /* счетчик по строкам от 1 до n */
 int j; /* счетчик по столбцам от 1 до m */
14
 for (i=0; i<n; i++) vn[i]=0; /* обнуление вектора-результата */
 for (i=0; i<n; i++)
 	for (j=0; j<m; j++)
 		vn[i] = vn[i] + mtr[i][j] * vm[j];
}
...
int vector[m]={1,2,3,4,5}; /* вектор-множитель */
int result[n]; /* вектор-результат */
Mult(matrix,vector,result);

возвращает одномерный массив vn[n] (изменяет значения его элементов)


Многомерный динамический массив (для матицы)
#define n 10 /* n - количество строк */
#define m 15 /* m - количество столбцов */
 int i, j; 
 
1) выделение непрерывного блока дин памяти для всех элементов матрицы:
 int *a;
 a = (int*)malloc(n*m*sizeof(int));
обращаться к значениям элементов такой матрицы придется как к элементам одномерного массива: a[i*m+j], *(a+i*m+j)

2) отдельные блоки дин памяти для каждой строки матрицы
int **a; /* Указатель на массив из n указателей на строки. */
 a = (int**)malloc(n*sizeof(int*)); /* Выделение памяти для */
 for (i=0; i<n; ++i) /* массива указателей. */
 a[i] = (int*)malloc(m*sizeof(int)); /* Выделение памяти */
 /* для строк матрицы. */
значения элементов a[i][j] или *(*(a+i)+j)
При данном способе 
- матрица занимает больше памяти
- строки хранятся в разных фрагментах памяти (невозможно работать со всеми элементами через непрерывное пространство адресов)
- при освобождении памяти нужно вызвать free() сначала для каждой строки матрицы a[i], а потом для массива указателей а
- время работы программы увеличивается за счет многократого выполнения malloc() и free()

3) непрерывный блок памяти для всех строк матрицы - объединение 1 и 2
 int **a; /* Указатель на массив из n указателей на строки. */
 a = (int**)malloc(n*sizeof(int*) + n*m*sizeof(int)); /* Общее
 выделение памяти для всех указателей и строк матрицы. */
 for (i=0; i<n; ++i)
 a[i] = (int*)(a+n) + i*m;
 /* Запись адресов строк в указатели на строки матрицы. */
элементы: a[i][j] или *(*(a+i)+j)
освобождение памяти:  free(a)
